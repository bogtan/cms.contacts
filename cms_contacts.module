<?php

/**
 * @file
 *   Used to implement general hooks and define Contacts' specific custom functions
 */

/**
 * Role to handle Contacts data
 */
define('ROLE_MANAGE_CONTACTS', 'manage contacts');

/**
 * Taxonomy vocabularies used only for Contacts data
 */
define('VOC_STATUS_ORGANIZATION', 'contacts_status_organization');
define('VOC_CONTACTS_REGION', 'contacts_regions');
define('VOC_CONTACTS_MAILING', 'contacts_mailing');
define('VOC_STATUS_PERSON', 'contacts_status_person');

/**
 * Include files for accessing LDAP data and API functions
 */
module_load_include('php', 'cms', 'CMSLDAP');
module_load_include('menu', 'cms_contacts', 'cms_contacts');
module_load_include('cron', 'cms_contacts', 'cms_contacts');
module_load_include('inc', 'cms_contacts', 'cms_contacts.api');

/**
 * Implements hook_permission().
 *
 * Define Contacts related permissions
 *
 * @return   array   Array of Contacts related permissions
 */
function cms_contacts_permission() {
    return array(
        'create contacts content' => array(
            'title' => t('Add, edit and delete available LDAP contacts'),
            'restrict access' => TRUE,
        ),
        'view contacts content' => array(
            'title' => t('View available LDAP contacts'),
        ),
        'edit own contacts content' => array(
            'title' => t('Edit own Contacts'),
            'restrict access' => TRUE,
        ),
        'edit any contacts content' => array(
            'title' => t('Edit any existing Contact'),
            'restrict access' => TRUE,
        ),
        'delete own contacts content' => array(
            'title' => t('Delete own Contacts'),
            'restrict access' => TRUE,
        ),
        'delete any contacts content' => array(
            'title' => t('Delete any existing contact'),
            'restrict access' => TRUE,
        ),
    );
}

/**
 * Implements hook_access().
 *
 * @param   string   $permission
 * @param   stdClass $account
 *
 * @todo Implement action logging;
 *
 * @return  boolean
 */
function cms_contacts_access($permission, $account = NULL) {
    global $user;

    if (!isset($account)) {
        $account = $user;
    }

    // Always allow access for 'admin' user
    if ($account->uid == 1) {
        return NODE_ACCESS_ALLOW;
    }

    // To reduce the number of SQL queries, we cache the user's permissions
    // in a static variable.
    // Use the advanced drupal_static() pattern, since this is called very often.
    static $drupal_static_fast;
    if (!isset($drupal_static_fast)) {
        $drupal_static_fast['perm'] = &drupal_static(__FUNCTION__);
    }

    $perm = &$drupal_static_fast['perm'];
    if (!isset($perm[$account->uid])) {
        $role_permissions = user_role_permissions($account->roles);

        $perms = array();
        foreach ($role_permissions as $one_role) {
            $perms += $one_role;
        }
        $perm[$account->uid] = $perms;
    }

    return isset($perm[$account->uid][$permission]);
}

/**
 * Implementes hook_theme();
 *
 * Define custom theme templates for Contacts
 *
 * @param   string   $existing
 * @param   string   $type
 * @param   stdClass $theme
 * @param   string   $path
 *
 * @param   array
 */
function cms_contacts_theme($existing, $type, $theme, $path) {
    $base = array(
        'file' => 'theme.inc',
        'path' => $path . '/theme',
    );
    return array(
        'contacts_list' => array(
            'template' => 'contacts/list',
            'arguments' => array(),
            'path' => drupal_get_path('theme', 'cms_theme') . '/templates',
        ),
        'contacts_organizations_list' => array(
            'template' => 'contacts/organizations/list',
            'arguments' => array(),
            'path' => drupal_get_path('theme', 'cms_theme') . '/templates',
        ),
        'contacts_departments_list' => array(
            'template' => 'contacts/departments/list',
            'arguments' => array(),
            'path' => drupal_get_path('theme', 'cms_theme') . '/templates',
        ),
        'contacts_view' => array(
            'template' => 'contacts/view',
            'arguments' => array(),
            'path' => drupal_get_path('theme', 'cms_theme') . '/templates',
        ),
        'contacts_organization_view' => array(
            'template' => 'contacts/organizations/view',
            'arguments' => array(),
            'path' => drupal_get_path('theme', 'cms_theme') . '/templates',
        ),
        'contacts_pagination' => array(
            'template' => 'contacts/pagination',
            'arguments' => array(),
            'path' => drupal_get_path('theme', 'cms_theme') . '/templates',
        ),
        'table__contacts_template_country' => $base + array(
                'variables' => array(
                    'header' => NULL,
                    'rows' => NULL,
                    'attributes' => array(),
                    'caption' => NULL,
                    'colgroups' => array(),
                    'sticky' => TRUE,
                    'empty' => '',
                    'settings' => array()
                )
            )
    );
}


/**
 * Implements hook_entity_view($entity, $type, $view_mode, $langcode)
 */
function cms_contacts_entity_view($entity, $type, $view_mode, $langcode){
    if($type != 'node' || $view_mode !== 'full') {
        return;
    }
    // Inject the national focal points into the country profile page
    if($entity->type == CMSContacts::$bundle_country_module) {
        $entity->content[CMSContacts::$field_contacts_country] =
            _contacts_get_contacts_render($entity, $view_mode);
    }
}


function _contacts_get_contacts_render($country, $view_mode) {
    $contacts = $country->national_focal_points[$country->language];
    $rows = array();
    foreach($contacts as $contact) {
        $row = $contact['entity'];
        $rows[] = array(
            'data' => array(
                sprintf('<a href="%s" onclick="%s">%s</a>',
                    "javascript:void(0);",
                    "alert('Not implemented'); return false;",
                    $row->name),
                'NOT IMPLEMENTED'
            )
        );
    }
    return array(
        '#theme' => 'table__contacts_template_country',
        '#weight' => 100, //@todo: computed
        '#access' => TRUE, '#label_display' => 'hidden', '#view_mode' => $view_mode,
        '#language' => $country->language,
        '#field_name' => CMSContacts::$field_contacts_country,
        '#field_type' => 'entityreference',
        '#entity_type' => 'node',
        '#bundle' => CMSContacts::$bundle_country_module,
        '#items' => $contacts,
        '#header' => array(t('Contact name'), t('Instrument(s)')),
        '#rows' => $rows,
        '#attributes' => array('class' => array('table', 'table-striped')),
        '#caption' => FALSE,
        '#colgroups' => array(),
        '#sticky' => TRUE,
        '#empty' => t('There are no national focal points for this country'),
        '#settings' => array()
    ) + $contacts;
}


/**
 * Implements hook_node_load()
 *
 * Attach $node->national_focal_points to country nodes for rendering of related NFPs
 */
function cms_contacts_node_load($nodes, $types) {
    foreach($nodes as $node) {
        switch($node->type) {
            case CMSContacts::$bundle_country_module:
                $nfps = CMSContacts::get_national_focal_points_for_country($node->nid);
                $node->national_focal_points[$node->language] = array();
                foreach($nfps as $row) {
                    $node->national_focal_points[$node->language][] = array(
                        'target_id' => $row->id,
                        'entity' => $row,
                        'access' => TRUE
                    );
                }
                break;
            default: break;
        }
    }
}


/**
 * Utility methods specific to species.
 */
class CMSContacts extends CMSBase {
    static $bundle_country_module = 'country';
    static $field_contacts_country = 'national_focal_points';
    static $ldap_options_cache_field = 'ldap_options_cache';

    static $mailing_list_cache = 'ldap_mailing_list_cache';
    static $status_person_cache = 'ldap_status_person_cache';
    static $status_organization_cache = 'ldap_status_organization_cache';
    static $users_cache = 'ldap_users_cache';
    static $instruments_cache = 'ldap_instruments_cache';
    static $organizations_cache = 'ldap_organizations_cache';

    // Headings for CSV and XLS exported files
    public static $export_file_headings = array(
        'Availability',
        'Personal title',
        'First name',
        'Last name',
        'Position',
        'Status person',
        'Organization',
        'Department',
        'Status organization',
        'Website',
        'Address',
        'Town/City',
        'Postal Code',
        'Country',
        'Region',
        'Country Post',
        'Work phone',
        'Mobile',
        'Fax',
        'Work email',
        'Personal e-mail',
        'Additional e-mails',
        'Home phone',
        'Skype',
        'CMS Instruments',
        'Mailing lists',
        'Description',
        'Preferred language',
        'Meetings',
        'Species',
    );

    // Contacts listing table columns
    // Used for sorting LDAP results
    public static $table_columns = array(
        'uid',
        'givenname',
        'sn',
        'o',
        'ou',
        'mail',
        'iso2',
        'cpiso2',
        'st',
        'conventions',
    );

    // Map Contacts form fields to LDAP cmsContact attributes
    private static $user_fields = array(
        'first_name' => 'givenName',
        'last_name' => 'sn',
        'conventions' => 'conventions',
        'personal_title' => 'personalTitle',
        'position' => 'title',
        'country' => 'iso2',
        'country_post' => 'cpIso2',
        'city' => 'st',
        'zip_code' => 'postalCode',
        'address' => 'street',
        'organization' => 'o',
        'department' => 'ou',
        'work_phone' => 'workPhoneNumbers',
        'home_phone' => 'homePhone',
        'fax_number' => 'faxNumbers',
        'mobile' => 'mobilePhoneNumbers',
        'website' => 'websites',
        'skype' => 'skype',
        'description' => 'description',
        'region' => 'region',
        'availability' => 'cmsAvailability',
        'organization_status' => 'statusOrganization',
        'mailing_list' => 'mailingLists',
        'person_status' => 'statusPerson',
        'preferred_language' => 'preferredLanguages',
        'additional_emails' => 'additionalEmails',
    );

    // Map Organization form fields to LDAP cmsOrganization attributes
    private static $organization_fields = array(
        'name' => 'o',
        'department' => 'ou',
        'country' => 'iso2',
        'country_post' => 'cpIso2',
        'city' => 'st',
        'zip_code' => 'postalCode',
        'address' => 'street',
        'region' => 'region',
        'availability' => 'cmsAvailability',
        'phone' => 'workPhoneNumbers',
        'fax_number' => 'faxNumbers',
        'description' => 'description',
        'conventions' => 'conventions',
        'mobile' => 'mobilePhoneNumbers',
        'website' => 'websites',
        'skype' => 'skype',
        'organization_status' => 'statusOrganization',
        'mailing_list' => 'mailingLists',
        'preferred_language' => 'preferredLanguages',
        'additional_emails' => 'additionalEmails',

    );

    // Map Department form fields to LDAP cmsDepartment attributes
    private static $department_fields = array(
        'name' => 'ou',
        'country' => 'iso2',
        'city' => 'st',
        'zip_code' => 'postalCode',
        'address' => 'street',
        'phone' => 'telephoneNumber',
        'fax_number' => 'facsimileTelephoneNumber',
        'description' => 'description',
        'conventions' => 'conventions',
    );

    /**
     * Connect to LDAP server and create new instance of LDAP agent
     *
     * @return   stdClass
     */
    public static function agent() {
        return new CMSLDAP();
    }

    /**
     * Search the LDAP for a given uid
     *
     * @param   string   $uid
     *    uid to search for
     * @param   stdClass $agent
     *    LDAP agent to handle the search bind and the retrieved results
     *
     * @return  array
     */
    public static function search_user($uid, $agent) {
        $agent->search($agent->people_dn, "(uid=$uid)");
        return $agent->get_entries();
    }

    /**
     * Check if a specified LDAP group already exists
     *
     * @param   string   $group_name
     * @param   stdClass $agent
     *
     * @return  boolean
     */
    public static function group_exists($group_name, $agent) {
        $agent->search($agent->people_dn, "(cn=$group_name)");
        $total = $agent->count_entries();
        return ($total) ? TRUE : FALSE;
    }

    /**
     * Check if a given user exists in a specified group
     *
     * @param   string   $group_name
     * @param   array    $user
     * @param   stdClass $agent
     *
     * @return  boolean
     */
    public static function user_in_group($group_name, $user, $agent) {
        if (isset($user['conventions']) && isset($user['conventions']['count'])) {
            unset($user['conventions']['count']);
            if (in_array($group_name, $user['conventions'])) {
                return TRUE;
            }
        }

        return FALSE;
    }

    /**
     * Check if a given organization exists in a specified group
     *
     * @param   string   $group_name
     * @param   array    $organization
     * @param   stdClass $agent
     *
     * @return  boolean
     */
    public static function organization_in_group($group_name, $organization, $agent) {
        if (isset($organization['conventions']) && $organization['conventions']['count']) {
            unset($organization['conventions']['count']);
            if (in_array($group_name, $organization['conventions'])) {
                return TRUE;
            }
        }

        return FALSE;
    }

    public static function update_contact_group_data($agent, $dn, $existing_groups = array(), $new_groups = array(), $only_add = FALSE) {
        $add_to_groups = array_diff($new_groups, $existing_groups);
        $remove_from_groups = array_diff($existing_groups, $new_groups);

        if ($add_to_groups) {
            foreach ($add_to_groups as $index => $group_dn) {
                @$agent->add_to_group($group_dn, array('uniqueMember' => $dn));
            }
        }

        if($remove_from_groups && !$only_add) {
            foreach ($remove_from_groups as $index => $group_dn) {
                @$agent->delete_from_group($group_dn, array('uniquemember' => $dn));
            }
        }
    }

    /**
     * Assign a given user to specified groups
     *
     * @param   string   $user_id
     * @param   array    $groups
     * @param   stdClass $agent
     */
    public static function update_user_groups($agent, $uid, $site_uuid, $user_data = array(), $only_add = FALSE) {
        $dn = 'uid=' . $uid . ',' . variable_get(LDAP_PEOPLE_DN, '');

        if ($only_add) {
            $contact_mailing_lists = $contact_statuses_person = $contact_statuses_organization = $contact_instruments = array();
        }else {
            $contact_mailing_lists = self::get_groups_for_contact(self::$mailing_list_cache, 'update_ldap_taxonomies_cache', $dn, $site_uuid);
            $contact_statuses_person = self::get_groups_for_contact(self::$status_person_cache, 'update_ldap_taxonomies_cache', $dn, $site_uuid);
            $contact_statuses_organization = self::get_groups_for_contact(self::$status_organization_cache, 'update_ldap_taxonomies_cache', $dn, $site_uuid);
            // Contact must be removed from all cmsInstrument groups so we'll not specify the site's UUID
            $contact_instruments = self::get_groups_for_contact(self::$instruments_cache, 'update_ldap_instruments_cache', $dn, '');
        }

        self::update_contact_group_data($agent, $dn, $contact_statuses_person, $user_data['statusPerson'], $only_add);
        self::update_contact_group_data($agent, $dn, $contact_statuses_organization, $user_data['statusOrganization'], $only_add);
        self::update_contact_group_data($agent, $dn, $contact_mailing_lists, $user_data['mailingLists'], $only_add);
        self::update_contact_group_data($agent, $dn, $contact_instruments, $user_data['conventions'], $only_add);
    }

    /**
     * Generate LDAP uid attribute' value based on user's first name and last name
     *
     * @param   string   $first_name
     * @param   string   $last_name
     *
     * @return  string
     */
    public static function generate_user_id($first_name = '', $last_name = '') {
        $first_name = CMSUtils::alphanumeric($first_name);
        $last_name = CMSUtils::alphanumeric($last_name);
        if (strlen($first_name) > 5) {
            $first_name = substr($first_name, 0, 5);
        }

        if (strlen($last_name) > 3) {
            $last_name = substr($last_name, 0, 5);
        }

        return strtolower($first_name . $last_name);
    }

    /**
     * Get User ID from DN
     *
     * @param   string   $dn
     * @return  string
     */
    public static function user_id_from_dn($dn = '') {
        $pattern = '/^uid\=[a-z]*/';
        preg_match($pattern, $dn, $matches);

        if (!empty($matches) && (strlen($matches[0]) > 5)) {
            return str_replace('uid=', '', $matches[0]);
        }else {
            return '';
        }
    }

    /**
     * Prepare Contacts' form data for LDAP insertion
     *
     * @param   array   $data
     * @param   boolean $edit
     *
     * @return  array   $department_data
     */
    public static function prepare_ldap_data($data = array(), $type = '', $edit = FALSE) {
        $ldap_data = array();

        switch ($type) {
            case 'cmsContact':
                $ldap_data = CMSContacts::prepare_user_data($data, $edit);

                break;
            default;
            case 'cmsOrganization':
                $ldap_data = CMSContacts::prepare_organization_data($data, $edit);

                break;

            case 'cmsDepartment':
                $ldap_data = CMSContacts::perpare_department_data($data, $edit);

                break;
        }
    }

    /**
     * Remove empty values from LDAP data in order to avoid "Invalid syntax" LDAP error
     *
     * @param   array   $data
     *
     * @return  array   $data
     */
    public static function clean_ldap_data(&$data, $edit = FALSE) {
        foreach($data as $key => $value){
            if ($key == 'cmsAvailability') {
                $data[$key][0] = (isset($value[0]) && ($value[0] != "FALSE")) ? "TRUE" : "FALSE";
            }else {
                if(is_array($value)) {
                    foreach($value as $key2 => $value2){
                        if(empty($value2)){
                            if ($edit) {
                                $data[$key][$key2] = array();
                            }else {
                                unset($data[$key][$key2]);
                            }
                        }
                    }
                }

                if(empty($data[$key])){
                    if ($edit) {
                        $data[$key] = array();
                    }else {
                        unset($data[$key]);
                    }
                }
            }
        }
    }

    /**
     * Prepare user data for LDAP insertion
     *
     * @param   array   $data
     * @param   boolean $edit
     *    If $edit is TRUE there is no need to generate another uid
     *
     * @return array    $ldap_data
     *
     * @todo   Timezone should have a customizable value
     */
    public static function prepare_user_data($data = array(), $edit = FALSE) {
        global $user;
        date_default_timezone_set("Europe/Berlin");

        // Manually set attributes that are not coming from the Contacts' add/edit form
        $ldap_data = array(
            'objectclass' => array(
                'top',
                'cmsContact',
            ),
            'lastModifiedTime' => array(
                time(),
            ),
            'lastModifiedBy' => array(
                $user->name,
            ),
        );

        // Manually manipulate different cases for LDAP attributes
        foreach (CMSContacts::$user_fields as $field => $ldap_field) {
            if (isset($data[$field]) && (!empty($data[$field]))) {
                if (in_array($field, array('mailing_list', 'organization_status', 'person_status', 'conventions'))) {
                    $ldap_data[$ldap_field] = array_keys($data[$field]);
                }elseif ($field == 'region') {
                    $term = taxonomy_term_load($data[$field]);
                    if ($term && $term->vocabulary_machine_name == VOC_REGION) {
                        $ldap_data[$ldap_field][] = $term->name;
                    }
                }elseif($field == 'preferred_language'){
                    if (!empty($data[$field])) {
                        $preferred_languages = array();
                        foreach ($data[$field] as $tid) {
                            $term = taxonomy_term_load($tid);
                            if ($term && $term->vocabulary_machine_name == VOC_UN_LANGUAGES) {
                                $preferred_languages[] = $term->name;
                                $preferred_languages['preferred_language'] = implode(',', $preferred_languages);
                            }
                        }
                        CMSContacts::set_multiple_attribute($ldap_data, $preferred_languages, 'preferred_language', CMSContacts::$user_fields['preferred_language']);
                    }
                }else {
                    $ldap_data[$ldap_field][0] = $data[$field];
                }
            }else {
                $ldap_data[$ldap_field] = array();
            }
        }

        $ldap_data['cmsAvailability'][0] = (isset($data['availability']) && ($data['availability'] != 'FALSE')) ? 'TRUE' : 'FALSE';
        $ldap_data['cn'][0] = $data['first_name'] . ' ' . $data['last_name'];

        CMSContacts::set_multiple_attribute($ldap_data, $data, 'email', 'mail');
        CMSContacts::set_multiple_attribute($ldap_data, $data, 'additional_emails', CMSContacts::$user_fields['additional_emails']);
        CMSContacts::set_multiple_attribute($ldap_data, $data, 'website', CMSContacts::$user_fields['website']);
        CMSContacts::set_multiple_attribute($ldap_data, $data, 'mobile', CMSContacts::$user_fields['mobile']);
        CMSContacts::set_multiple_attribute($ldap_data, $data, 'work_phone', CMSContacts::$user_fields['work_phone']);
        CMSContacts::set_multiple_attribute($ldap_data, $data, 'fax_number', CMSContacts::$user_fields['fax_number']);

        if (isset($data['personal_email']) && (!empty($data['personal_email']))) {
            $ldap_data['personalEmail'][] = $data['personal_email'];
        }

        // Clean LDAP data before insertion
        CMSContacts::clean_ldap_data($ldap_data, $edit);

        if (!$edit) {
            if ((!empty($data['first_name'])) && (!empty($data['last_name']))) {
                $ldap_data['uid'][0] = CMSContacts::generate_user_id($data['first_name'], $data['last_name']);
            }
        }

        return $ldap_data;
    }

    /**
     * Before insertion multiple valued attributes must be associative arrays
     *
     * @param   array   $ldap_data
     * @param   array   $data
     * @param   string  $field
     *    Drupal Contacts' form field
     * @param   string  $ldap_field
     *    LDAP field name
     */
    public static function prepare_multiple_valued_attribute(&$ldap_data, $data, $field, $ldap_field) {
        if (array_key_exists($field, $data) && (!empty($data[$field]))) {
            foreach($data[$field] as $value) {
                $ldap_data[$ldap_field][] = $value;
            }
        }
    }

    /**
     * Prepare organization data for LDAP insertion
     *
     * @param   array   $data
     * @param   boolean $edit
     *
     * @return  array   $organization_data
     */
    public static function prepare_organization_data($data = array(), $edit = FALSE) {
        global $user;

        $ldap_data = array(
            'objectclass' => array(
                'top',
                'organization',
                'cmsOrganization',
            ),
            'lastModifiedTime' => array(
                time(),
            ),
            'lastModifiedBy' => array(
                $user->name,
            ),
        );

        foreach (CMSContacts::$organization_fields as $field => $ldap_field) {
            if (isset($data[$field]) && (!empty($data[$field]))) {
                if ($field == 'conventions') {
                    $ldap_data[$ldap_field] = array_keys($data[$field]);
                }elseif ($field == 'organization_status') {
                    $ldap_data[$ldap_field] = CMSContacts::contact_map_terms_by_ids(VOC_STATUS_ORGANIZATION, array_keys($data[$field]));
                }elseif ($field == 'mailing_list') {
                    $ldap_data[$ldap_field] = CMSContacts::contact_map_terms_by_ids(VOC_CONTACTS_MAILING, array_keys($data[$field]));
                }elseif ($field == 'region') {
                    $term = taxonomy_term_load($data[$field]);
                    if ($term && $term->vocabulary_machine_name == VOC_REGION) {
                        $ldap_data[$ldap_field][] = $term->name;
                    }
                }elseif($field == 'preferred_language'){
                    $terms = taxonomy_term_load_multiple($data[$field]);
                    if ($terms) {
                        foreach ($terms as $term) {
                            if ($term->vocabulary_machine_name == VOC_UN_LANGUAGES) {
                                $ldap_data[$ldap_field][] = $term->name;
                            }
                        }
                    }
                }else {
                    $ldap_data[$ldap_field][0] = $data[$field];
                }
            }else {
                $ldap_data[$ldap_field] = array();
            }
        }

        $ldap_data['cmsAvailability'][0] = (isset($data['availability']) && ($data['availability'] != 'FALSE')) ? 'TRUE' : 'FALSE';

        CMSContacts::set_multiple_attribute($ldap_data, $data, 'email', 'mail');
        CMSContacts::set_multiple_attribute($ldap_data, $data, 'additional_emails', 'additionalEmails');
        CMSContacts::set_multiple_attribute($ldap_data, $data, 'website', 'websites');

        CMSContacts::clean_ldap_data($ldap_data, $edit);

        if (!$edit) {
            $ldap_data['oid'] = CMSUtils::random_string();
        }

        return $ldap_data;
    }

    /**
     * Prepare department data for LDAP insertion
     *
     * @param   array   $data
     * @param   boolean $edit
     *
     * @return  array   $ldap_data
     */
    public static function prepare_department_data($data = array(), $edit = FALSE) {
        $ldap_data = array(
            'objectclass' => array(
                'top',
                'organizationalUnit',
                'cmsDepartment',
            ),
        );

        foreach (CMSContacts::$department_fields as $field => $ldap_field) {
            if (isset($data[$field]) && (!empty($data[$field]))) {
                if ($field == 'conventions') {
                    $ldap_data[$ldap_field] = array_keys($data[$field]);
                }else {
                    $ldap_data[$ldap_field] = $data[$field];
                }
            }else {
                $ldap_data[$ldap_field] = NULL;
            }
        }

        CMSContacts::clean_ldap_data($ldap_data, $edit);

        if (!$edit) {
            $ldap_data['did'] = CMSUtils::random_string();
        }

        return $ldap_data;
    }

    /**
     * User structure for CSV file export
     *
     * @param   array   $data
     * @param   array   $user
     * @param   string  $attribute
     *
     * @return  boolean
     */
    public static function prepare_user_to_csv(&$data, $user, $attribute) {
        if ((!isset($user[$attribute])) || (empty($user[$attribute]))) {
            if ($attribute == 'mail') {
                $data[] = '';
                $data[] = '';
            }else {
                $data[] = '';
            }

            return true;
        }

        if ($attribute == 'conventions') {
            unset($user[$attribute]['count']);
            $data[] = implode(', ', $user[$attribute]);
            return;
        }elseif ($attribute == 'mail') {
            (int) $count = $user[$attribute]['count'];
            unset($user[$attribute]['count']);
            if ($count == 1) {
                $data[] = $user[$attribute][0];
                $data[] = '';
            }elseif ($count == 2) {
                $data[] = $user[$attribute][0];
                $data[] = $user[$attribute][1];
            }else {
                $data[] = '';
                $data[] = '';
            }

            return true;
        }elseif ($attribute == 'additionalemails'){
            unset($user[$attribute]['count']);
            $data[] = implode('; ', $user[$attribute]);
            return;
        }

        if ($user[$attribute]['count'] == 1) {
            if (($attribute == 'iso2') || ($attribute == 'cpiso2')) {
                $country = Country::get_by_iso2(strtolower($user[$attribute][0]));
                if ($country) {
                    $string = $country->title;
                }else {
                    $string = $user[$attribute][0];
                }
            }else {
                $string = $user[$attribute][0];
            }
        }elseif ($user[$attribute]['count'] > 1) {
            unset($user[$attribute]['count']);
            $string = implode('; ', $user[$attribute]);
        }

        $data[] = $string;

        return true;
    }

    /**
     * Check if a specified organization name exists.
     * Create the organization if it doesn't exists.
     *
     * @param   string   $organization_name
     * @param   array    $conventions
     *
     * @return  array    $organization
     */
    public static function get_or_create_organization($organization_name = '', $conventions = array()) {
        $conventions = array_combine($conventions, $conventions);
        $organization = array();
        $agent = CMSContacts::agent();
        $filter = '(&(objectClass=cmsOrganization)(o=' . $organization_name . '))';
        if (!$agent->connected) {
            drupal_set_message('Unable to connect to the LDAP server! Please contact site administrator.', 'error');
        }else {
            $result = $agent->search($agent->organization_dn, $filter);
            $organizations = $agent->get_entries();
            if ($organizations['count']) {
                $organization = $organizations[0];
            }else {
                $organization = CMSContacts::prepare_organization_data(array('name' => $organization_name,
                                                                             'conventions' => $conventions));
                $dn = "oid=" . $organization['oid'] . "," . $agent->organization_dn;

                if(!$agent->add($dn, $organization)) {
                    drupal_set_message(t('The organization could not be saved.'), 'error');
                }
            }
        }

        return $organization;
    }

    /**
     * Check if a specified department name exists.
     * Create the department if it doesn't exists.
     *
     * @param   string   $department_name
     * @param   array    $conventions
     *
     * @return  $array   $department
     */
    public static function get_or_create_department($department_name = '', $conventions = array()) {
        $conventions = array_combine($conventions, $conventions);
        $department = array();
        $agent = CMSContacts::agent();
        $filter = '(&(objectClass=cmsDeparment)(ou=' . $department_name . '))';

        if (!$agent->connected) {
            drupal_set_message('Unable to connect to the LDAP server! Please contact site administrator.', 'error');
        }else {
            $result = $agent->search($agent->department_dn, $filter);
            $departments = $agent->get_entries();
            if ($departments['count']) {
                $department = $departments[0];
            }else {
                $department = CMSContacts::prepare_department_data(array('name' => $department_name,
                                                                         'conventions' => $conventions));
                $dn = "did=" . $department['did'] . "," . $agent->department_dn;

                if(!$agent->add($dn, $department)) {
                    drupal_set_message(t('The department could not be saved.'), 'error');
                }
            }
        }

        return $department;
    }

    /**
     * Create a list of terms IDs of a specified list of terms names
     *
     * @param   array $contact
     *    An array with contact details
     * @param   string $attribute
     *    Attribute name where names are stored on contact
     * @param   array $terms
     *    An associative array of terms IDs and terms names for the specified attribute
     *
     * @return  array   $contact_terms
     */
    public static function contact_map_terms($contact = array(), $attribute = '', $terms = array()) {
        $contact_terms = array();
        if (isset($contact[$attribute]) && (isset($contact[$attribute]['count'])) && ($contact[$attribute]['count'])) {
            foreach ($contact[$attribute] as $key => $contact_term) {
                if (is_numeric($key)) {
                    $tid = array_search($contact_term, $terms);

                    if ($tid) {
                        $contact_terms[] = $tid;
                    }
                }
            }
        }

        return $contact_terms;
    }

    /**
     * Given a vocabulary machine name and an array of terms IDs return a list with terms names
     *
     * @param   string $vocabulary_name
     *    Vocabulary machine name where to look for specified terms IDs
     * @param   array $tids
     *    IDs of terms for which to get the names
     *
     * return   array   $contact_terms
     *    List of terms names
     */
    public static function contact_map_terms_by_ids($vocabulary_name = '', $tids = array()) {
        $contact_terms = array();

        $terms = taxonomy_term_load_multiple($tids);
        if ($terms) {
            foreach ($terms as $tid => $term) {
                if ($term->vocabulary_machine_name == $vocabulary_name) {
                    $contact_terms[] = $term->name;
                }
            }
        }

        return $contact_terms;
    }

    /**
     * Retrieve all Contacts CN (Canonical Names) based on a specified filter
     *
     * @param   string   $filter
     * @param   boolean  $associative
     *    If $associative is TRUE then return an associative array with uid and name:
     *    array(
     *        'id' => '<uid>',
     *        'name' => '<cn>',
     *    )
     *
     * @return  array    $result
     */
    public static function get_mapped_contacts_names_uid($filter = '', $associative = FALSE) {
        $result = array();
        $agent = CMSContacts::agent();

        $ldap_filter = '(objectClass=cmsContact)';
        if (!empty($filter)) {
            $ldap_filter = '(&' . $ldap_filter . $filter . ')';
        }

        if (!$agent->connected) {
            drupal_set_message('Unable to connect to the LDAP server! Please contact site administrator.', 'error');
        }else {
            $agent->search($agent->people_dn, $ldap_filter);
            $contacts = $agent->get_entries();
            if ($contacts['count']) {
                unset($contacts['count']);
                foreach ($contacts as $index => $contact) {
                    if ($associative) {
                        $result[] = array(
                            'id' => $contact['uid'][0],
                            'name' => $contact['cn'][0],
                        );
                    }
                    $result[$contact['uid'][0]] = $contact['cn'][0];
                }
            }
        }

        return $result;
    }

    /**
     * Get Drupal content related to a specified LDAP user
     *
     * @param   string   $uid
     * @param   string   $content_type
     *    Drupal content type to retrieve
     * @param   string   $field
     *    Drupal field on which the LDAP uid is held
     * @param   boolean  $only_title
     *    If $only_title is True do not return the whole Drupal $node details
     *
     * @return  array    $related_nodes
     */
    public static function get_contact_related_content($uid = '', $content_type = '', $field = '', $only_title = FALSE) {
        $related_nodes = array();
        $query = new EntityFieldQuery();
        $query = $query->entityCondition('entity_type', 'node')
            ->propertyCondition('type', $content_type)
            ->fieldCondition($field, 'value', $uid, '=')
            ->execute();
        if(isset($query['node']) && !empty($query['node'])) {
            foreach ($query['node'] as $nid => $node_details) {
                $node = node_load($nid);
                if ($node) {
                    if ($only_title) {
                        $related_nodes[] = $node->title;
                    }else {
                        $related_nodes[] = $node;
                    }
                }
            }
        }

        return $related_nodes;
    }

    /**
     * Set LDAP contact on speciefied content type
     *
     * @param   string   $uid   Contact unique identifier
     * @param   array    $nids  IDs of Drupal nodes for which to set the LDAP contact
     * @param   string   $content_type   Drupal node type
     * @param   string   $fields   Drupal node's field on which to save the relation with the LDAP contact
     */
    public static function set_contact_related_content($uid = '', $nids = array(), $content_type = '', $field = '') {
        $existing_content = CMSContacts::get_contact_related_content($uid, $content_type, $field);
        foreach ($existing_content as $node) {
            if (!in_array($node->nid, $nids)) {
                $wrapper = entity_metadata_wrapper('node', $node);
                $values = $wrapper->{$field}->raw();
                $key = array_search($uid, $values);
                if ($key !== FALSE) {
                    unset($node->{$field}[$node->language][$key]);
                }
                node_save($node);
            }
        }

        if (!empty($nids)) {
            foreach($nids as $nid) {
                $node = node_load($nid);
                if ($node) {
                    $related_nodes = CMSBase::get_field_list_value($node, $fields);
                    if (!in_array($uid, $related_nodes)) {
                        $node->{$field}[$node->language][count($related_nodes)]['value'] = $uid;
                        node_save($node);
                    }
                }
            }
        }else {
            $related_nodes = CMSContacts::get_contact_related_content($uid, $content_type, $field);
            foreach ($related_nodes as $node) {
                $node->{$field}[$node->language] = array();
                node_save($node);
            }
        }
    }

    /**
     * Manually handle multiple valued LDAP attributes on Contacts add/edit save
     *
     * @param   array   $ldap_data
     *    Data to be saved in LDAP database
     * @param   array   $data
     *    Data retrieved from Drupal Contacts add/edit form
     * @param   string  $field
     *    Drupal Contacts add/edit form field name
     * @param   string  $ldap_attribute
     *    LDAP attribute on which the data will be saved
     */
    public static function set_multiple_attribute(&$ldap_data = array(), $data = array(), $field = '', $ldap_attribute = '') {
        $ldap_data[$ldap_attribute] = array();
        if (isset($data[$field]) && (!empty($data[$field]))) {
            $values = explode(',', $data[$field]);
            foreach ($values as $value) {
                $value = trim($value);
                if (!in_array($value, array_values($ldap_data[$ldap_attribute]))) {
                    $ldap_data[$ldap_attribute][] = $value;
                }
            }
        }
    }

    /**
     * Create a string with values of a multiple valued LDAP attribute
     *
     * @param   string   $contact
     *    LDAP contact data
     * @param   string   $ldap_attribute
     *
     * @return  string   $value
     */
    public static function get_multiple_attribute($contact = array(), $ldap_attribute = '') {
        $value = '';
        if (isset($contact[$ldap_attribute]) && $contact[$ldap_attribute]['count']) {
            foreach ($contact[$ldap_attribute] as $index => $attribute_value) {
                if (is_numeric($index)) {
                    $value .= $attribute_value;
                    if (($index + 1) < $contact[$ldap_attribute]['count']) {
                        $value .= ", ";
                    }
                }
            }
        }

        return $value;
    }


    /**
     * Retrieve the national focal points assigned to a specified country
     * @param $id_country integer Country to filter by
     * @return mixed Array of focal point objects
     */
    public static function get_national_focal_points_for_country($id_country) {
        //@todo: Not implemented
        $dummy = new stdClass();
        $dummy->id = 1;
        $dummy->name = 'John Doe';
        return array($dummy);
    }

    /**
     * Update LDAP taxonomies cache
     * The cache contains mailing lists, statuses of person and statuses of organization
     */
    public static function update_ldap_taxonomies_cache() {
        $agent = self::agent();
        if (!$agent->connected) {
            drupal_set_message('Unable to connect to the LDAP server! Please contact site administrator.', 'error');
        }else {
            $filter = "(|(objectClass=" . CMS_MAILING. ")(objectClass=" . CMS_STATUS_PERSON . ")(objectClass=" . CMS_STATUS_ORGANIZATION . "))";
            $result = $agent->search($agent->base_dn, $filter);
            $lists = $agent->get_entries();

            if ($lists) {
                unset($lists['count']);
                foreach ($lists as $index => $list) {
                    $pattern = '/uuid\=(.*?)\,o\=CMS/';
                    preg_match($pattern, $list['dn'], $matches, PREG_OFFSET_CAPTURE);
                    if (isset($matches[1])) {
                        $uuid = $matches[1][0];
                        $list['friendly_title'] = $list['cn'][0] . " (" . $list['in'][0] . ")";

                        switch ($list['objectclass'][1]) {
                            case CMS_MAILING:
                                $mailing_list[$list['dn']] = $list;
                                break;
                            case CMS_STATUS_PERSON:
                                $status_person[$list['dn']] = $list;
                                break;
                            case CMS_STATUS_ORGANIZATION:
                                $status_organization[$list['dn']] = $list;
                                break;
                        }
                    }
                }
            }

            if ($mailing_list) {
                cache_set(self::$mailing_list_cache, $mailing_list, 'cache', time() + 60 * 5);
            }

            if ($status_person) {
                cache_set(self::$status_person_cache, $status_person, 'cache', time() + 60 * 5);
            }

            if ($status_organization) {
                cache_set(self::$status_organization_cache, $status_organization, 'cache', time() + 60 * 5);
            }
        }
    }

    /**
     * Cache all LDAP entries with objectClass CMS_CONTACT (default cmsContact)
     */
    public static function update_ldap_users_cache() {
        $agent = self::agent();
        if (!$agent->connected) {
            drupal_set_message(t('Unable to connect to the LDAP server! Please contact site administrator'), 'error');
        }else {
            $filter = "(objectClass=" . CMS_CONTACT . ")";
            $result = $agent->search($agent->base_dn, $filter);
            $users = $agent->get_entries();
            CMSUtils::unset_count_key($users);

            $data_to_cache = array();
            foreach ($users as $index => $user) {
                $data_to_cache[$user['dn']] = $user;
            }

            if ($data_to_cache) {
                # Create cache and keep it for 1 hour
                cache_set(self::$users_cache, $data_to_cache, 'cache', time() + 60 * 60);
            }
        }
    }

    /**
     * Cache all LDAP groups with objectClass CMS_INSTRUMENT (default cmsInstrument)
     */
    public static function update_ldap_instruments_cache() {
        $agent = self::agent();
        if (!$agent->connected) {
            drupal_set_message(t('Unable to connect to the LDAP server! Please contact site administrator'), 'error');
        }else {
            $filter = "(objectClass=" . CMS_INSTRUMENT . ")";
            $result = $agent->search($agent->base_dn, $filter);
            $instruments = $agent->get_entries();
            CMSUtils::unset_count_key($instruments);

            $data_to_cache = array();
            foreach ($instruments as $index => $instrument) {
                $data_to_cache[$instrument['dn']] = $instrument;
            }

            if ($data_to_cache) {
                # Create cache and keep it for 1 hour
                cache_set(self::$instruments_cache, $data_to_cache, 'cache', time() + 60 * 60);
            }
        }
    }

    public static function update_ldap_organizations_cache() {
        $agent = self::agent();
        if (!$agent->connected) {
            drupal_set_message(t('Unable to connect to the LDAP server! Please contact site administrator'), 'error');
        }else {
            $filter = "(objectClass=" . CMS_ORGANIZATION . ")";
            $result = $agent->search($agent->base_dn, $filter);
            $organizations = $agent->get_entries();
            CMSUtils::unset_count_key($organizations);

            $data_to_cache = array();
            foreach ($organizations as $index => $organization) {
                $data_to_cache[$organization['dn']] = $organization;
            }

            if ($data_to_cache) {
                # Create cache and keep it for 1 hour
                cache_set(self::$organizations_cache, $data_to_cache, 'cache', time() + 60 * 60);
            }
        }
    }

    /**
     * Get a specified Drupal cache or create it if it does not exists
     *
     * @param    string    $cid
     *  Drupal cache unique identifed
     * @param    string    $callback
     *  Callback function which creates the cache
     */
    public static function get_or_create_ldap_cache($cid, $callback, $remove_count = TRUE) {
        if ($cache = cache_get($cid)) {
            $cache_data = $cache->data;
        }else {
            self::$callback();
            $cache_data = cache_get($cid)->data;
        }

        if ($remove_count) {
            CMSUtils::unset_count_key($cache_data);
        }

        return $cache_data;
    }

    public static function get_list_from_cache($list_name, $cache_data) {
        $list = array();
        foreach ($cache_data as $index => $cache_list) {
            if ($cache_list['cn'][0] == $list_name) {
                $list = $cache_list;
            }
        }

        return $list;
    }

    public static function get_contact_from_cache($contact_dn) {
        $contact_dn = 'uid=' . $contact_dn . ',' . variable_get(LDAP_PEOPLE_DN, '');
        $contacts = CMSContacts::get_or_create_ldap_cache(CMSContacts::$users_cache, 'update_ldap_users_cache');
        $contact = array();
        if (!empty($contacts) && (array_key_exists($contact_dn, $contacts))) {
            $contact = $contacts[$contact_dn];
        }

        return $contact;
    }

    public static function create_form_options_for_field($cid = '', $callback = '') {
        $options = array();
        $cache = CMSContacts::get_or_create_ldap_cache($cid, $callback);
        $instrument_uuid = variable_get('site_uuid', '');
        if (!$instrument_uuid) {
            drupal_set_message('Unable to determine site UUID!', 'error');
        }elseif ($cache) {
            foreach ($cache as $dn => $item) {
                if ($item['uuid'][0] == $instrument_uuid && !array_key_exists($dn, array_keys($options))) {
                    $options[$dn] = $item['cn'][0];
                }
            }
        }

        return $options;
    }

    public static function create_instruments_form_options() {
        $options = array();
        $cache = CMSContacts::get_or_create_ldap_cache(self::$instruments_cache, 'update_ldap_instruments_cache');
        if ($cache) {
            foreach ($cache as $dn => $item) {
                $options[$dn] = $item['cn'][0];
            }
        }

        return $options;
    }

    public static function get_groups_for_contact($cid, $callback, $dn,  $site_uuid = '') {
        $cache = CMSContacts::get_or_create_ldap_cache($cid, $callback);
        $lists_dns = array();
        foreach ($cache as $index => $item) {
            if (!$site_uuid) {
                if (in_array($dn, $item['uniquemember']) && (!in_array($item['dn'], $lists_dns))) {
                    $lists_dns[] = $item['dn'];
                }
            }else {
                if (in_array($dn, $item['uniquemember']) && (!in_array($item['dn'], $lists_dns)) && ($site_uuid == $item['uuid'][0])) {
                    $lists_dns[] = $item['dn'];
                }
            }
        }

        return $lists_dns;
    }

    public static function get_friendly_title_groups_for_contact($cid, $callback, $dn,  $site_uuid = '') {
        $cache = CMSContacts::get_or_create_ldap_cache($cid, $callback);
        $lists_dns = array();
        foreach ($cache as $index => $item) {
            if (!$site_uuid) {
                if (in_array($dn, $item['uniquemember']) && (!in_array($item['dn'], $lists_dns))) {
                    $lists_dns[] = $item['cn'][0];
                }
            }else {
                if (in_array($dn, $item['uniquemember']) && (!in_array($item['dn'], $lists_dns)) && ($site_uuid == $item['uuid'][0])) {
                    $lists_dns[] = $item['cn'][0];
                }
            }
        }

        return $lists_dns;
    }

    public static function remove_contact_from_groups($agent, $dn = '', $site_uuid) {
        $contact_mailing_lists = self::get_groups_for_contact(self::$mailing_list_cache, 'update_ldap_taxonomies_cache', $dn, $site_uuid);
        $contact_statuses_person = self::get_groups_for_contact(self::$status_person_cache, 'update_ldap_taxonomies_cache', $dn, $site_uuid);
        $contact_statuses_organization = self::get_groups_for_contact(self::$status_organization_cache, 'update_ldap_taxonomies_cache', $dn, $site_uuid);
        // Contact must be removed from all cmsInstrument groups so we'll not specify the site's UUID
        $contact_instruments = self::get_groups_for_contact(self::$instruments_cache, 'update_ldap_instruments_cache', $dn, '');

        if ($contact_instruments) {
            foreach ($contact_instruments as $index => $group_dn) {
                @$agent->delete_from_group($group_dn, array('uniquemember' => $dn));
            }
        }

        if ($contact_mailing_lists) {
            foreach($contact_mailing_lists as $index => $group_dn) {
                @$agent->delete_from_group($group_dn, array('uniquemember' => $dn));
            }
        }

        if ($contact_statuses_person) {
            foreach($contact_statuses_person as $index => $group_dn) {
                @$agent->delete_from_group($group_dn, array('uniquemember' => $dn));
            }
        }

        if ($contact_statuses_organization) {
            foreach($contact_statuses_organization as $index => $group_dn) {
                @$agent->delete_from_group($group_dn, array('uniquemember' => $dn));
            }
        }
    }
}
